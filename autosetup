#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import tempfile
import urllib.request
from enum import Enum
from pathlib import Path
from dataclasses import dataclass, field
from typing import List, Dict, Set, Tuple, Optional

# ----------------------------------------------------------------------------
# Constants and Configuration
# ----------------------------------------------------------------------------

VERSION = "1.1"

temp_dir: Optional[tempfile.TemporaryDirectory] = None

# ANSI color codes for output
COLORS = {
    'COMMENTARY': '\033[94m', # Blue
    'SUCCESS':    '\033[92m', # Green
    'WARNING':    '\033[93m', # Yellow
    'ERROR':      '\033[91m', # Red
    'NOTICE':     '\033[97m', # White
    'PHASE':      '\033[95m', # Magenta 
    'INFO':       '\033[96m', # Cyan
    'END':        '\033[0m'
}

APT_SOURCES_DIR: str = "/etc/apt/sources.list.d"

# ----------------------------------------------------------------------------
# Data classes
# ----------------------------------------------------------------------------

# Installation phases
class Phase(Enum):
    START = 'start'
    REGULAR = 'regular'
    END = 'end'

# Installed package database
@dataclass
class PackageDatabase:
    """Class to manage the installed package database."""

    installed_packages: Set[str] = field(default_factory=set)

    def load(self) -> None:
        """Load the list of installed packages."""

        try:
            result = subprocess.run(
                ['apt', 'list', '--installed'],
                capture_output=True, text=True, check=True
            )
            self.installed_packages = {
                p.split('/')[0] 
                for p in result.stdout.splitlines()[1:] 
                if '/' in p
            }
        except subprocess.CalledProcessError:
            bail("Error getting list of installed packages")

    def is_installed(self, package: str) -> bool:
        """Check if a package is already installed."""
    
        return package in self.installed_packages

# Package class
@dataclass
class PackageAttributes:
    class ScriptPhase(Enum):
        PRE_INSTALL =  'prescript'
        POST_INSTALL = 'postscript'

    name:            str = None
    install_method:  str = 'apt'  # 'apt' or 'deb'
    url:             Optional[str] = None    # for deb downloads
    repositories:    Set[str] = field(default_factory=set)
    sources:         List[tuple[str, str]] = field(default_factory=list)  # [(filename, content),...]
    scripts:         Dict[ScriptPhase, str] = field(default_factory=dict)
    flags:           Set[str] = field(default_factory=set)
    downloaded_file: Optional[str] = None
    apt_package:     str = None
    _SEMAPHORE_DIR:  Path = Path("/var/run/autosetup")

    # Class-level constant
    SCRIPT_ONCE_FLAGS = {
        ScriptPhase.PRE_INSTALL:  'prescript_run_once',
        ScriptPhase.POST_INSTALL: 'postscript_run_once'
    }
    SCRIPT_BOTH_ONCE_FLAG = 'script_run_once'

    def has_flags(self, *flags: str) -> bool:
        """Check if the package has any of the given flags."""
        return bool(self.flags & set(flags))
    
    def run_once(self, phase: ScriptPhase) -> bool:
        """Check if the script should only be run once."""
        return self.has_flags(self.SCRIPT_ONCE_FLAGS[phase]) or self.has_flags(self.SCRIPT_BOTH_ONCE_FLAG)
    
    def add_scripts(self, phase: ScriptPhase, script: str) -> None:
        """Add a script to the package."""
        self.scripts[phase] = script

    def get_script(self, phase: ScriptPhase) -> str:
        """Get the script for the given phase."""
        return self.scripts.get(phase, None)

    def include_package(self, only: Set[str], only_flags: Set[str], skip: Set[str], skip_flags: Set[str]) -> bool:
        """ Return TRUE if this package should be included in the installation """

        if skip and self.name in skip:
            return False
        
        if skip_flags and self.flags & skip_flags:
            return False
        
        if only and self.name not in only:
            return False
        
        if only_flags and not self.flags & only_flags:
            return False
        
        return True

    def pretty_script(self, script: ScriptPhase) -> str:
        """Format script commands for display."""

        s = self.get_script(script)
        return f"    " + s  # TODO: this needs to be improved
    
    def pretty_print_script(self, script: ScriptPhase) -> None:
        print(f"{self.pretty_script(script)}")
    
    # Semaphore functions
    def _semaphore_name(self, phase: ScriptPhase) -> str:
        """Return the semaphore filename for a package and script phase."""
   
        return self._SEMAPHORE_DIR / f"{self.name}.{self.SCRIPT_ONCE_FLAGS[phase]}"

    def semaphore_create(self, phase: ScriptPhase):
        """Create an semaphore file for this package, for the script phase."""
    
        path = self._semaphore_name(phase)    

        if args.dryrun:
            info(f"Would create semaphore file: {path}")
            return
        
        path.parent.mkdir(parents=True, exist_ok=True)  # Create all parent directories
        try:
            path.touch()
        except OSError as e:
            bail(f"Could not create semaphore file {path}: {e}")

    def semaphore_exists(self, phase: ScriptPhase) -> bool:
        """Check if a semaphore exists for this package and script phase."""
        return self._semaphore_name(phase).is_file()
    
# PackageList: List of Package Attributes
@dataclass
class PackageList:
    _packages:          List[PackageAttributes] = field(default_factory=list)
    _apt_update_needed: bool = False

    def __iter__(self):
        return iter(self._packages)
         
    def __bool__(self) -> bool:
        return bool(self._packages)
   
    def __str__(self) -> str:
        """Format package list into columns for display."""
  
        if not self:
            return "  None"

        try:
            terminal_width = os.get_terminal_size().columns
        except (AttributeError, OSError):
            terminal_width = 80

        pkg_names = sorted([pkg.name for pkg in self._packages])
        max_length = max(len(name) for name in pkg_names)
        column_width = max_length + 2
        num_columns = max(1, terminal_width // column_width)

        num_rows = (len(pkg_names) + num_columns - 1) // num_columns

        output = []
        for row in range(num_rows):
            line = []
            for col in range(num_columns):
                idx = col * num_rows + row
                if idx < len(pkg_names):
                    line.append(pkg_names[idx].ljust(column_width))
            output.append("  " + "".join(line).rstrip())

        return "\n".join(output)
   
    def append(self, pkg: PackageAttributes):
        self._packages.append(pkg)
  
    def get_packages_with_flags(self, *flags: str) -> 'PackageList':
        matching_packages = []

        for pkg in self._packages:
            if pkg.has_flags(*flags):
                matching_packages.append(pkg)

        return PackageList(_packages=matching_packages)
   
    def get_packages_without_flags(self, *flags: str) -> 'PackageList':
        matching_packages = []
       
        for pkg in self._packages:
            if not pkg.has_flags(*flags):
                matching_packages.append(pkg)

        return PackageList(_packages=matching_packages)
    
    #-------------------------------------------------
    # Package List Parsing
   
    def _filter_comments(self, line: str) -> str:
        """Remove comments but preserve # characters in quoted strings."""

        if not line:
            return line
        
        result = []    
        in_quote = False
        quote_char = None
        i = 0
        
        while i < len(line):
            char = line[i]
            
            # Handle quotes
            if char in '"\'':
                if not in_quote:
                    in_quote = True
                    quote_char = char
                elif char == quote_char:
                    in_quote = False
                    quote_char = None
                    
            # Handle comment outside of quotes
            elif char == '#' and not in_quote:
                break
                
            result.append(char)
            i += 1
        
        return ''.join(result).rstrip()

    def _parse_directive(self, line: str, pkg: PackageAttributes) -> bool:
        """Parse a single directive line and update package attributes."""

        try:
            dtype, content = line.split(':', 1)
        except ValueError:
            return False

        dtype = dtype.strip().lower()
        content = content.strip()
        
        match dtype:
            case 'flags':
                pkg.flags.update(f.strip().lower() for f in content.split(','))
            case 'deb':
                pkg.install_method = 'deb'
                pkg.url = content
            case 'repo':
                pkg.repositories.add(content)
            case 'source':
                try:
                    fname, src = content.split(None, 1)
                    fname = str(Path(APT_SOURCES_DIR).joinpath(Path(fname).name))
                    pkg.sources.append((fname, src))
                except ValueError:
                    bail(f"Invalid source format: {content}")
            case PackageAttributes.ScriptPhase.PRE_INSTALL.value:
                pkg.add_scripts(PackageAttributes.ScriptPhase.PRE_INSTALL, content)
            case PackageAttributes.ScriptPhase.POST_INSTALL.value:
                pkg.add_scripts(PackageAttributes.ScriptPhase.POST_INSTALL, content)
            case 'apt':
                pkg.apt_package = content
            case _:
                return False
        return True

    def load(self, filename: Path) -> None:
        """Parse package list file into list of PackageAttributes."""
        self._packages = []
        current_pkg = None
    
        # Read and process file
        if not filename.is_file():
            bail(f"Package file '{filename}' does not exist or is not readable.")

        try:
            with open(filename) as f:
                lines = []
                continued = ''
                
                for line_num, line in enumerate(f, start=1):
                    # Handle comments and empty lines
                    line = self._filter_comments(line.rstrip())
                    if not line:
                        continue
                        
                    # Handle line continuation
                    if line.endswith('\\'):
                        continued += line[:-1] + '\n'
                        continue
                    
                    if continued:
                        line = continued + line
                        continued = ''
                    
                    # Package name or directive?
                    if not line.startswith(' '):
                        # New package
                        if ':' in line and not line.endswith(':'):
                            bail(f"Invalid package format at line {line_num}: {line}\n  Package names and directives must be on separate lines")
                        
                        name = line.rstrip(':')
                        current_pkg = PackageAttributes(name=name, apt_package=name)
                        self.append(current_pkg)
                    else:
                        # Directive
                        if not current_pkg:
                            bail(f"Directive without package name at line {line_num}")
                        if not self._parse_directive(line.strip(), current_pkg):
                            bail(f"Unknown directive at line {line_num}: {line}")
        except OSError as e:
            bail(f"Error reading {filename}: {e}")

    ##########
    # Installers

    def run_script(self, phase: PackageAttributes.ScriptPhase = None):
        """Run a list of (script, package) pairs."""

        if not self:
            return
            
        commentary(f"Running {phase} scripts")

        for package in self._packages:
            script = package.get_script(phase)

            if not script:
                continue

            run_once = package.run_once(phase)

            if run_once and package.semaphore_exists(phase):
                info(f"{phase} script for {package.name} already run, skipping")
                continue

            if args.dryrun:
                info(f"Would run {phase} script for {package.name}:")
                if args.debug:
                    package.pretty_print_script(phase)
                continue
                
            info(f"Running {phase} script for {package.name}:")
            if args.debug:
                package.pretty_print_script(phase)
            
            try:
                subprocess.run(script, **run_opts, shell=True, check=True)
                success(f"Completed {phase} script for {package.name}")
                if run_once:
                    package.semaphore_create(phase)
            except subprocess.CalledProcessError as result:
                error(f"Error running {phase} script:")
                package.pretty_print_script(phase)
                error(f"Return code: {result.returncode}")
                bail(f"Script error for package {package.name}")

    def download_packages(self) -> None:
        """Download packages that have URLs, updating package entry with downloaded file name """

        if not self:
            return 

        commentary("Downloading packages") 

        for package in self._packages:
            url = package.url

            filename = package.name
            filename += ".deb"
            
            if args.dryrun:
                info(f"Would download: {url} for package {package.name}")
                package.downloaded_file = filename
                continue

            try:
                info(f"Downloading {url}")
                info(f"    to file {filename}")
                opener = urllib.request.build_opener(urllib.request.HTTPRedirectHandler())
                urllib.request.install_opener(opener)           
                urllib.request.urlretrieve(url, filename)
            
                if not Path(filename).is_file():
                    bail(f"Downloaded file {filename} not found")

                package.downloaded_file = filename
                success(f"Downloaded {filename} successfully")
            except Exception as e:
                bail(f"Error downloading from URL {url}: {e}")

    def install_downloads(self) -> None:
        """Install downloaded packages."""

        if not self:
            return

        commentary(f"Installing downloaded packages")

        plst: str = None
        for package in self._packages:
            if args.dryrun:
                info(f"Would install file {package.downloaded_file} for package {package.name}")
                continue

            info(f"Installing downloaded package file {package.downloaded_file} for package {package.name}")
            try:
                subprocess.run(['dpkg', '-i', package.downloaded_file], **run_opts, check=True)
                success(f"Installed {package.downloaded_file} successfully")
            except subprocess.CalledProcessError:
                bail(f"Error installing {package.downloaded_file}")

    def apt_install(self) -> None:
        """Install packages via apt."""

        if not self:
            return 
        
        commentary("Installing apt packages")

        if args.dryrun:
            info(f"Would install apt packages:")
            notice(f"{self}")
            return
        
        plst = [package.name for package in self._packages]
        try:
            subprocess.run(['apt', '-y', 'install', '--reinstall'] + plst, **run_opts, check=True)
            success("Package installation completed successfully")
        except subprocess.CalledProcessError:
            bail("Error installing packages")

    def add_repositories(self) -> None:
        """Add repositories to . """

        if not self:
            return

        commentary(f"Adding repositories")

        for package in self._packages:
            for repo in package.repositories:
                if args.dryrun:
                    info(f"Would add repository: {repo}")
                    continue

                try:
                    info(f"Adding repository: {repo}")
                    subprocess.run(['add-apt-repository', '-y', repo], **run_opts, check=True)
                    success(f"Added repository: {repo}")
                    _apt_update_needed = True
                except subprocess.CalledProcessError:
                    bail(f"Error adding repository: {repo}")

    def add_sources(self) -> None:
        """Add sources to /apt/sources.list.d/... """
        # Note: I don't think we can use add-apt-repository here, as it is important to keep any new 
        # sources we add in separate files in /etc/sources.list.d/, so we do it by hand.

        if not self:
            return False

        commentary(f"Adding package sources")

        for package in self._packages: 
            for filename, content in package.sources:
                if args.dryrun:
                    info(f"Would add '{content}' to {filename}")
                    continue

                try:
                    if not Path(filename).is_file():
                        info(f"Adding source file: {filename}")
                        with open(filename, 'w') as sources_file:
                            sources_file.write(f"{content}\n")
                        success(f"Added package source in {filename}")
                        _apt_update_needed = True 
                    else:
                        warning(f"'{filename}' exists, skipping")
                except Exception as e:
                    bail(f"Error adding source to {filename}: {e}")

    def is_apt_update_needed(self) -> bool:
        """Check if an apt update is needed."""
        return self._apt_update_needed
    
    def update_apt_database(self) -> None:
        """ Force update apt package database """
    
        if args.dryrun:
            info("Would update apt package database")
            return

        info("Updating package database")
        try:
            subprocess.run(['apt', 'update'], **run_opts, check=True)
            success("Package database updated")
        except subprocess.CalledProcessError:
            bail("Error updating package database")
    
    def install(self) -> None:
        """Process all installation steps for the given packages."""
    
        if not self:
            return
        
        apt_update_needed = False

        # All packages for which an action is needed, collated by action 
        repos = PackageList([])
        sources = PackageList([])
        pre_scripts = PackageList([])
        post_scripts = PackageList([])
        urls = PackageList([])
        apt_packages = PackageList([])

        # Skipped packages, collated by skip reason
        cmdline = PackageList([])
        already_installed = PackageList([])
        flag = PackageList([])

        for pkg in self._packages:
            # Apply command line filters, save data to tell the user what we did and why
            if not pkg.include_package(args.only, args.only_flags, args.skip, args.skip_flags):
                cmdline.append(pkg)
                continue

            force = 'force' in pkg.flags or args.force_all

            if installedPackages.is_installed(pkg.name) and not force: 
                already_installed.append(pkg)
                continue

            if pkg.has_flags("skip"):
                flag.append(pkg)
                continue

            # Sort out which packages have pre_scripts, post_scripts, urls to download, etc.
            if pkg.has_flags('force_apt_update'):
                apt_update_needed = True

            if pkg.repositories:
                repos.append(pkg)
            if pkg.sources:
                sources.append(pkg)
            if pkg.get_script(PackageAttributes.ScriptPhase.PRE_INSTALL):
                pre_scripts.append(pkg)
            if pkg.get_script(PackageAttributes.ScriptPhase.POST_INSTALL):
                post_scripts.append(pkg)
            if pkg.url and pkg.install_method == 'deb':
                urls.append(pkg)
            if pkg.install_method == 'apt' and 'no_apt' not in pkg.flags: 
                apt_packages.append(pkg)
        
        # Report on skipped packages, if any
        if cmdline:
            info(f"Packages skipped due to command line options:")
            print(f"{cmdline}")
        if flag:
            info(f"Packages skipped due to flags:")
            print(f"{flag}")
        if already_installed:
            info(f"Skipping already installed packages:")
            print(f"{already_installed}")
        
        # Any packages left?
        if not any([repos, sources, pre_scripts, post_scripts, urls, apt_packages]):
            info("  No packages left to install")
            return
        
        ### Start the installation process

        sources.add_sources()
        repos.add_repositories()
        pre_scripts.run_script(PackageAttributes.ScriptPhase.PRE_INSTALL)
        urls.download_packages()
        urls.install_downloads()
        if repos.is_apt_update_needed() or sources.is_apt_update_needed() or apt_update_needed:
            apt_packages.update_apt_database()
        apt_packages.apt_install()
        post_scripts.run_script(PackageAttributes.ScriptPhase.POST_INSTALL) 

# ----------------------------------------------------------------------------
# Output Functions
# ----------------------------------------------------------------------------

def colored_output(msg: str, color: str, prefix: str = "==>", is_error: bool = False):
    """Print colored output with prefix."""
    stream = sys.stderr if is_error else sys.stdout
    if prefix:
        prefix += " "
    print(f"{COLORS[color]}{prefix}{msg}{COLORS['END']}", file=stream, flush=True)

def info(msg: str):
    colored_output(msg, 'INFO')

def success(msg: str):
    colored_output(msg, 'SUCCESS')

def commentary(msg: str):
    colored_output(msg, 'COMMENTARY')

def warning(msg: str):
    colored_output(msg, 'WARNING', "==> WARNING:")

def error(msg: str):
    colored_output(msg, 'ERROR', "==> ERROR:", True)

def notice(msg: str):
    colored_output(msg, 'NOTICE', "")

def phase(msg: str):
    colored_output(msg, 'PHASE', "**")

# ----------------------------------------------------------------------------
# Environment Management
# ----------------------------------------------------------------------------

def make_working_directory():
    """Create and manage a temporary working directory."""

    global temp_dir 
    
    try:
        temp_dir = tempfile.TemporaryDirectory(suffix='_pkg_install')
        os.chdir(temp_dir.name)
    except OSError as e:
        bail(f"Failed to change to temp directory: {e}")

def bail(message: str = None, exit_code: int = 1):
    """Exit the program with optional error message."""
   
    if message:
        error(message)

    if temp_dir:
        if args.preserve:
            info(f"Preserving working directory: {temp_dir}")
            temp_dir._finalizer.detach()  # Prevent deletion
        else:
            try:
                temp_dir.cleanup
            except OSError as e:
                error(f"Failed to remove working directory: {e}")
            
    sys.exit(exit_code)

def root_check():
    """Verify root privileges when not in dry-run mode."""
    
    if os.geteuid() != 0 and not args.dryrun:
        bail("This script must be run as root")
 
# ----------------------------------------------------------------------------
# Main Program
# ----------------------------------------------------------------------------

def comma_separated_to_set(alist: List[str]) -> Set[str]:
    """Parse out a comma-separated list of comments into a set of strings """
    
    items = set()

    if alist:
        for a in alist:
            for arg in a.split(','):
                items.add(arg.strip())

    return items

def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
 
    global args

    parser = argparse.ArgumentParser(
        description='Install packages and manage package repository dependencies',
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('-n', '--dryrun', action='store_true',
                      help='Dry run (do not actually install packages)')
    parser.add_argument('-p', '--preserve', action='store_true',
                      help='Preserve the temporary working directory')
    parser.add_argument('-v', '--version', action='version',
                      version=f'%(prog)s version {VERSION}')
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='Squelch subprocess output')
    parser.add_argument('--debug', action='store_true', 
                        help='Print any script source before execution')
    parser.add_argument('filename', help='Package list file')
    parser.add_argument('--skip', nargs=1, 
                      help=f'Do not install package these packages (comma separated)')
    parser.add_argument('--skip-flags', nargs=1,
                      help=f'Do not install packages with these flags (comma separated)')
    parser.add_argument('--only-flags', nargs=1,
                        help='Only install packages with these flags (comma separated)')
    parser.add_argument('--only', nargs=1,
                        help='Only install these packages (comma separated)')
    parser.add_argument('--force-all', action='store_true',
                        help='Force install all the packages')
    
    args = parser.parse_args()

    # Parse out comma separated arguments into sets
    args.skip = comma_separated_to_set(args.skip)
    args.skip_flags = comma_separated_to_set(args.skip_flags)
    args.only_flags = comma_separated_to_set(args.only_flags)
    args.only = comma_separated_to_set(args.only)

    # Redirect subprocess output?
    global run_opts
    run_opts = {}
    if args.quiet:
        run_opts = {
            'stdout': subprocess.DEVNULL,
            'stderr': subprocess.DEVNULL
        }

    # Validate input file
    args.filename = Path(args.filename).resolve()
    

def main():

    parse_arguments()

    global installedPackages
    installedPackages = PackageDatabase()
    installedPackages.load()

    global packageEntries 
    packageEntries = PackageList()
    packageEntries.load(args.filename)
    
    if not packageEntries:
        commentary(f"No packages in package list '{args.filename}'")
        return
  
    # Set up environment
    make_working_directory()
    if not args.dryrun:
        root_check()

    # Start installation process
    notice("Starting package installation")

    # Break package list into the different package phases based on per package flags

    for p in Phase:
        phase_name = p.value
        phase(f"Starting Phase: {phase_name}")
        
        if p == Phase.REGULAR:
            packages = packageEntries.get_packages_without_flags(Phase.START.value, Phase.END.value)
        else:
            packages = packageEntries.get_packages_with_flags(phase_name)

        packages.install()
        phase(f"Phase complete")


    notice("Installation complete")

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        bail("\nInstallation interrupted by user")
    except Exception as e:
        if '--debug' in sys.argv:
            raise
        bail(f"Unexpected error: {e}")
